Supermart Grocery Sales
# -*- coding: utf-8 -*-
"""Super mart Gorcery store retail Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pd8TR-m6TjsdtnDtkH38yohjiXhpKXjM

# ***Supermart Grocery Sales - Data Science Project***

---



The Supermart Grocery Sales project is a retail analytics data science project focused on exploring and predicting grocery sales using a dataset of customer orders from a fictional grocery delivery app in Tamil Nadu, India.

## OVERVIEW:

Here’s an overview of the key steps and components of this project:

**Tools and Technologies:** Python, SQL, Excel, and Machine Learning (ML) libraries. Intermediate level project for data analysts and data scientists.

**Dataset Description:** The dataset includes details on orders, such as Order ID, Customer Name, Category, Sub Category, City, Order Date, Region, Sales, Discount, Profit, and more.

It aims to help analysts practice data exploration, visualization, and predictive modeling.

**Project Steps:**

**Data Import and Preprocessing:** Load the data, check for missing values, duplicates, and convert date columns to the appropriate format. Categorical columns are encoded for model compatibility.

**Exploratory Data Analysis (EDA):** Visualizations include distribution of sales by category, monthly and yearly sales trends, and a correlation heatmap. Analysis of sales trends by category, city, and month to understand purchasing patterns. Feature Engineering: Extract new features from the order date (e.g., month and year), and prepare categorical data for modeling.

**Model Building and Evaluation:** A linear regression model is built to predict sales based on selected features. Model performance is evaluated using Mean Squared Error (MSE) and R-squared (R²) metrics. Results Visualization: Actual vs. predicted sales, and visualizations of sales patterns by city and time.

**Conclusion:** The linear regression model provides a reasonable prediction, with a decent R² value indicating the model’s fit. Suggestions for improvement include trying advanced models like Random Forest or XGBoost, feature engineering, and potentially deploying the model in a real-time dashboard for business insights.

# Data Cleaning and Preprocessing:

After loading the dataset, we inspected it for any Null values ,Unique values ,extracted values from data set and converted date columns into a proper datetime format. We also removed unnecessary columns to streamline the analysis and removed specific outliers in Profit, Discount, and Sales to prevent distortion of results.We Also inspected the features No. of (Count,Sales, Discount, and Profit) by category,sub-category ,Region, City,year, Month, & day, ensure to get an Idea and followng the proper way to do analysis.

**IMPORTING LIBRARIES**
"""

#IMPORTING NECESSARY LIBRARIES
#Load "numpy" & "pandas" for manipulating numbers & Dataframes
#Load "matplotlib.pyplot" & "seaborn" for data visualization

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""**READING CSV File**"""

#Read the "supermart Gorcery sales.csv" file as a pandas Dataframe
data = pd.read_csv("/content/Supermart Grocery Sales - Retail Analytics Dataset.csv")

"""**DATASET OF CSV File**"""

#Take a breif Look at the Data
data.head()

"""**SHAPE OF THE DATA FRAME**"""

#Get the dimensions of the dataframe
data.shape

"""**SIZE OF THE DATA FRAME**"""

#Get the size of the Data Frame
data.size

"""**ROWS IN THE DATA FRAME**"""

#Get the rows (index) names of the data frame
data.index

"""**COLUMNS IN THE DATA FRAME**"""

#Get the column names of the dataframe
data.columns

"""**INFO OF THE DATA FRAME**"""

#look at the basic information about the Dataframe
data.info()

"""**NULL VALUES IN THE DATAFRAME**"""

#Check for Missing Values and Handle Them
data.isnull().sum()

"""**UNIQUE VALUES IN THE DATAFRAME**"""

#unique values in customer name column
data['Customer Name'].unique()

#unique values in category column
data['Category'].unique()

#Unique values in sub category column
data['Sub Category'].unique()

#Unique values in city column
data['City'].unique()

#Unique value in region column
data['Region'].unique()

# Drop any rows with missing values
data.dropna(inplace=True)

# Check for duplicates
data.drop_duplicates(inplace=True)

"""**Converting orderdate column to date time format**"""

#sample Data from order date column
data['Order Date'].sample(5)

#converting order date column to pandas datetime format
#by using (format="mixed") because order date has mixed format data
data['Order Date'] = pd.to_datetime(data['Order Date'], format="mixed")

#sample Data from order date column after transformation
data['Order Date'].sample(5)

"""**Extracting year, month & date from order date column**"""

#Extracting year, month & date from order date column
data['Order Year'] = data['Order Date'].dt.year
data['Order Month'] = data['Order Date'].dt.month
data['Order Day'] = data['Order Date'].dt.day

"""**Extracting Discount amount from discount column**"""

#Extracting Discount amount from discount column
#We are extracting discount amount from discount percentage by using formula : CP=(SP*100/100-discount%)
data['Discount Amount'] = (data['Sales'] * 100 / 100 - data['Discount'])

"""**Data Preprocessing & Dropping Unnecessary Columns**"""

# Data Preprocessing
# Converting 'Order Date' to datetime format and dropping unnecessary columns for analysis
data['Order Day'] = pd.to_datetime(data['Order Day'], format='mixed', dayfirst=True)
data.drop(['Order ID', 'Customer Name', 'State'], axis=1, inplace=True)
data.head()

"""**FINAL DATAFRAME**"""

#final data frame
data.head(9)

""" **No.of products sold  in each category ,Sub-category ,Region,City**"""

#counts of products sold in each category
data['Category'].value_counts()

#counts of products sold in each Sub-category
data['Sub Category'].value_counts()

#counts of products sold in each city
data['City'].value_counts()

#counts of products sold in each region
data['Region'].value_counts()

#As we have only 1 sales dat for north region thus we can remove it for a balance data overall
data = data[data['Region'] != 'North']

#counts of products sold in each region after transformation
data['Region'].value_counts()

"""**No.of products sold each year,month & date**"""

#count of products sold each year
data['Order Year'].value_counts()

#count of products sold each month
data['Order Month'].value_counts()

#count of products sold each date.
data['Order Day'].value_counts()

"""**Total sales in each Category, Sub-category,City, Region, Month, year**"""

#Total sale in each category
data.groupby('Category')['Sales'].sum()

#Total sale in each sub-category
data.groupby('Sub Category')['Sales'].sum()

#Total sale in each region
data.groupby('Region')['Sales'].sum()

#Total sale in each city
data.groupby('City')['Sales'].sum()

#Total sale in each month
data.groupby('Order Month')['Sales'].sum()

#Total sale in each year
data.groupby('Order Year')['Sales'].sum()

"""**Total Profit in each Category, Sub-category,City, Region, Month, year**"""

#Total profit in each category
data.groupby('Category')['Profit'].sum()

#Total profit in each sub-category
data.groupby('Sub Category')['Profit'].sum()

#Total profit in each region
data.groupby('Region')['Profit'].sum()

#Total profit in each city
data.groupby('City')['Profit'].sum()

#Total profit in each month
data.groupby('Order Month')['Profit'].sum()

#Total profit in each year
data.groupby('Order Year')['Profit'].sum()

"""**Total Discount in each Category, Sub-category,City, Region, Month, year**"""

#Total Discount on each product category
data.groupby('Category')['Discount'].sum()

#Total Discount on each product sub-category
data.groupby('Sub Category')['Discount'].sum()

#Total Discount in each region
data.groupby('Region')['Discount'].sum()

#Total Dicount on each city
data.groupby('City')['Discount'].sum()

#Total Discount on each month
data.groupby('Order Month')['Discount'].sum()

#Total Discount on each year
data.groupby('Order Year')['Discount'].sum()

"""**Sales of different Category products, Region, Month, year**"""

#sales of different cateogory products year wise
data.pivot_table(index='Category', columns='Order Year', values='Sales', aggfunc='sum')

#sales of different cateogory products month wise
data.pivot_table(index='Category', columns='Order Month', values='Sales', aggfunc='sum')

#sales of different cateogory products Region wise
data.pivot_table(index='Category', columns='Region', values='Sales', aggfunc='sum')

"""**Profit from different Category products, Region, Month, year**"""

#profit from different category products region wise
data.pivot_table(index='Category', columns='Region', values='Profit', aggfunc='sum')

#profit from different category products year wise
data.pivot_table(index='Category', columns='Order Year', values='Profit', aggfunc='sum')

#profit from different category products month wise
data.pivot_table(index='Category', columns='Order Month', values='Profit', aggfunc='sum')

"""**Removing Outliners from our final data frame**"""

# Outlier Removal
# Removing outliers in 'Profit', 'Discount', and 'Sales' columns based on known thresholds
data = data[data['Profit'] != 2000]
data = data[data['Discount'] != 200]
data = data[data['Sales'] != 1000]

"""# Exploratory Data Analysis (EDA)
Boxplots were generated to identify outliers in the Profit, Discount, and Sales features, which provided insight into the distribution and variability of these key metrics.A bar plot is visualized for total (count,sales,profit,discount) by (category,sub-category,region,city,month, year,day)helps us to identified the better business decisions.we also provided the insights which will be easy to understand the feature.

A bar plot visualized the Sales by Category, helping identify which product categories contribute most significantly to sales. Time series analysis using line plots helped observe Sales Trends Over Time, showing seasonal or monthly variations in sales. A correlation heatmap revealed relationships among various numerical features, allowing us to understand potential multicollinearity and feature importance.

**Visualizing Outliers Using Boxplot**
"""

# Visualizing Outliers
# Using boxplots to visualize potential outliers in 'Profit', 'Discount', and 'Sales'
plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
sns.boxplot(data['Profit']).set_title('Profit')
plt.subplot(1, 3, 2)
sns.boxplot(data['Discount']).set_title('Discount')
plt.subplot(1, 3, 3)
sns.boxplot(data['Sales']).set_title('Sales')
plt.tight_layout()
plt.show()

"""**No.of products sold in each category ,Sub-category ,city, region**

**INSIGHTS:**

Snacks are the highest selling product in the entire category.
While, Oil and Masala being the lowest selling product in the entire category.



"""

#distrubution plot by Product-sold count in Category wise

plt.figure(figsize=(12,5))
ax = sns.countplot(x='Category',data=data) # Assign the return value of sns.countplot to ax
plt.title('No.of products sold in each Category')
plt.xlabel('Category')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])
plt.show()

"""
**INSIGHTS:**

 Health Drinks and Soft Drinks are the top 2 highest selling products in the entire sub category.
Cookies is the third highest selling product in the entire sub category.
While, Rice being the lowest selling product in the entire sub category."""

#distrubution plot by Product-sold count in Sub-Category wise
plt.figure(figsize=(35,10))
ax = sns.countplot(x='Sub Category',data=data) # Assign the return value of sns.countplot to ax
plt.title('No.of products sold in each Sub-Category')
plt.xlabel('Sub Category')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])
plt.show()

"""
**INSIGHTS:**

Kanyakumari is the city with highest number of sales in whole Tamil
NaduWhile, Trichy being the city with lowest number of sales in whole Tamil Nadu."""

#distrubution plot by Product-sold count in City wise
plt.figure(figsize=(12,5))
# Assign the return value of sns.countplot to ax
ax = sns.countplot(x='City',data=data)
plt.title('No.of products sold in each City')
plt.xlabel('City')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])  # Now ax is defined and can be used
plt.show()

"""
**INSIGHTS:**

West is the region with highest number of sales in Tamil Nadu.While, South being the region with lowest number of sales in Tamil Nadu."""

#distrubution plot by Product-sold count in Region wise
plt.figure(figsize=(12,5))
# Assign the return value of sns.countplot to ax
ax = sns.countplot(x='Region', data=data)
plt.title('No.of products sold in each Region')
plt.xlabel('Region')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0]) # Now ax is defined and can be used
plt.show()

"""**No.of products sold in each year,month & date**

**INSIGHTS:**

2018 was the year with highest number of sales.While, 2015 being the year with lowest number of sales.
"""

#distrubution plot by Product-sold count in year wise
plt.figure(figsize=(12,5))
# Assign the return value of sns.countplot to ax
ax = sns.countplot(x='Order Year',data=data)
plt.title('No.of products sold in each Year')
plt.xlabel('Year')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])
plt.show()

#distrubution plot by Product-sold count in Month wise
plt.figure(figsize=(12,5))
# Assign the return value of sns.countplot to ax
ax = sns.countplot(x='Order Month',data=data)
plt.title('No.of products sold in each Year')
plt.xlabel('Month')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])
plt.show()

"""***Converting Order month value from int to string ***"""

import calendar
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# ... (your existing code) ...

# Assuming you have a column named 'Order Month' with integer values
if 'Order Month' in data.columns:
    # Convert month integers to month names
    data['Order Month'] = data['Order Month'].apply(lambda x: calendar.month_name[x])
else:
    raise ValueError("The 'Order Month' column is missing in the DataFrame.")

# ... (your existing plotting code using 'Order Month' for x-axis) ...

"""**INSIGHTS:**

November is the month with highest number of sales.While, February being the month with lowest number of sales.High sales are towards the end of the year while low sales are towards the start of the year.
"""

#distrubution plot by Product-sold count in Month wise after tranformation
plt.figure(figsize=(12,5))
# Assign the return value of sns.countplot to ax
ax = sns.countplot(y='Order Month',data=data)
plt.title('No.of products sold in each Year')
plt.ylabel('Month')
plt.xlabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])
plt.show()

"""**INSIGHTS:**

20 and 21 are the dates in each month with highest number of sales. While, 31 being the date in each month with lowest number of sales.High sales are towards the mid of each month while low sales are towards the end of each month.
"""

#distrubution plot by Product-sold count in Day wise
plt.figure(figsize=(12,5))
# Assign the return value of sns.countplot to ax
ax = sns.countplot(x='Order Day',data=data)
plt.title('No.of products sold in each Day')
plt.xlabel('Day')
plt.ylabel('Count')
plt.xticks(rotation=90)
ax.bar_label(ax.containers[0])
plt.show()

"""**Total sales in each Category, Sub-category,City ,Region,year& Month**.

**INSIGHTS:**

 Eggs, Meat & Fish has the highest number of total sales in the entire category.While, Oil and Masala has the lowest number of total sales in the entire category
"""

#distrubution of plot of Total Sales vs cateogry

from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'Category' and 'Sales' are your columns

# Calculate total sales per category
sales_by_category = data.groupby('Category')['Sales'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(10, 6))
ax = sns.barplot(x=sales_by_category.index, y=sales_by_category.values, color="red")
plt.title('Total Sales by Each Category')
plt.xlabel('Category')
plt.ylabel('Total Sales')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in sales_by_category.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

Health Drinks and Soft Drinks has the highest number of total sales in the entire sub category.While, Rice has the lowest number of total sales in the entire sub category.
"""

#distrubution of plot of Total Sales vs sub-cateogry..
from matplotlib.ticker import FuncFormatter
# Calculate total sales per sub-category
sales_by_sub_category = data.groupby('Sub Category')['Sales'].sum().sort_values(ascending=False)
# Create the bar plot
plt.figure(figsize=(20, 10))
ax = sns.barplot(x=sales_by_sub_category.index, y=sales_by_sub_category.values, color="red")
plt.title('Total Sales by Each Sub-Category')
plt.xlabel('Sub-Category')
plt.ylabel('Total Sales')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in sales_by_sub_category.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

West region has the highest number of total sales in the entire city. While, South region has the lowest number of total sales in the entire city.
"""

#distrubution of plot by Total Sales vs Region
from matplotlib.ticker import FuncFormatter
# Calculate total sales per region
sales_by_region = data.groupby('Region')['Sales'].sum().sort_values(ascending=False)
# Create the bar plot
plt.figure(figsize=(12, 5))
ax = sns.barplot(x=sales_by_region.index, y=sales_by_region.values, color="red")
plt.title('Total Sales by Each Region')
plt.xlabel('Region')
plt.ylabel('Total Sales')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in sales_by_region.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

Kanyakumari is the city with the highest number of total sales in Tamil Nadu.While, Trichy is the city with the lowest number of total sales in Tamil Nadu.
"""

#distrubution of plot of Total Sales vs city
from matplotlib.ticker import FuncFormatter
# Calculate total sales per city
sales_by_city = data.groupby('City')['Sales'].sum().sort_values(ascending=False)
# Create the bar plot
plt.figure(figsize=(20,
                    5))
ax = sns.barplot(x=sales_by_city.index, y=sales_by_city.values, color="red")
plt.title('Total Sales by Each City')
plt.xlabel('City')
plt.ylabel('Total Sales')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in sales_by_city.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**.
.
2018 was the year with the highest number of total sales.While, 2015 being the year with the lowest number of total sales
"""

#distrubution of plot of Total Sales vs each year
from matplotlib.ticker import FuncFormatter
## Calculate total sales per year
sales_by_year = data.groupby('Order Year')['Sales'].sum().sort_values(ascending=False)
# Create the bar plot
plt.figure(figsize=(15, 5))
ax = sns.barplot(x=sales_by_year.index, y=sales_by_year.values, color="red")
plt.title('Total Sales by Each Year')
plt.xlabel('Year')
plt.ylabel('Total Sales')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in sales_by_year.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

November is the month with the highest number of total sales in each Year.While, February is the month with the lowest number of total sales in each Year
"""

#distrubution of plot of Total Sales vs each month
from matplotlib.ticker import FuncFormatter
# Calculate total sales per month
sales_by_month = data.groupby('Order Month')['Sales'].sum().sort_values(ascending=False)
# Create the bar plot
plt.figure(figsize=(16, 5))
ax = sns.barplot(x=sales_by_month.index, y=sales_by_month.values, color="red")
plt.title('Total Sales by Each Month')
plt.xlabel('Month')
plt.ylabel('Total Sales')
#setting integer formatting for y-axis and bar labels
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in sales_by_month.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**Total Profit in each Category, Sub-category,City ,Region,year& Month**.

**INSIGHTS:**

Snacks was the most profitable category of product in the Supermarket.While, Oil & Masala being the least profitable category of product in the Supermarket.
"""

#distrubution of plot of Total Profit vs cateogry

from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'Category' and 'Profit' are your columns

# Calculate total profit per category
profit_by_category = data.groupby('Category')['Profit'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(10, 6))
ax = sns.barplot(x=profit_by_category.index, y=profit_by_category.values, color="yellow")
plt.title('Total Profit by Each Category')
plt.xlabel('Category')
plt.ylabel('Total Profit')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in profit_by_category.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

Health Drinks & Soft Drinks are the most profitable sub category of products in the Supermarket.While, Chicken being the least profitable sub category of product in the Supermarket.
"""

#distrubution of plot of Total Profit vs sub-cateogry

from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'Category' and 'Profit' are your columns

# Calculate total profit per sub-category
profit_by_sub_category = data.groupby('Sub Category')['Profit'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(18, 8))
ax = sns.barplot(x=profit_by_sub_category.index, y=profit_by_sub_category.values, color="yellow")
plt.title('Total Profit by Sub-Category')
plt.xlabel('Sub-Category')
plt.ylabel('Total Profit')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in profit_by_sub_category.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

West was the most profitable region of the Supermarket.While, South being the least profitable region of the Supermarket.
"""

#distrubution of plot of Total Profit vs Region
from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'Region' and 'Profit' are your columns

# Calculate total profit per sub-category
profit_by_region = data.groupby('Region')['Profit'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(18, 8))
ax = sns.barplot(x=profit_by_region.index, y=profit_by_region.values, color="yellow")
plt.title('Total Profit by Region')
plt.xlabel('Region')
plt.ylabel('Total Profit')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in profit_by_region.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

Vellore was the most profitable city in Tamil Nadu.While, Trichy being the least profitable city in Tamil Nadu.
"""

#distrubution of plot of Total Profit vs city
from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'City' and 'Profit' are your columns

# Calculate total profit per sub-category
profit_by_city = data.groupby('City')['Profit'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(18, 8))
ax = sns.barplot(x=profit_by_city.index, y=profit_by_city.values, color="yellow")
plt.title('Total Profit by City')
plt.xlabel('City')
plt.ylabel('Total Profit')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in profit_by_city.values]) #fixed this line
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

2018 was the most profitable year for the Supermarket.While, 2015 being the least profitable year for the Supermarket.
"""

#distrubution of plot of Total Profit vs year
from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'year' and 'Profit' are your columns

# Calculate total profit per year
profit_by_year = data.groupby('Order Year')['Profit'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(18, 8))
ax = sns.barplot(x=profit_by_year.index, y=profit_by_year.values, color="yellow")
plt.title('Total Profit by Year')
plt.xlabel('Year')
plt.ylabel('Total Profit')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in profit_by_year.values]) #fixed this
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**INSIGHTS:**

November was the most profitable month for the Supermarket.While, February being the least profitable month for the Supermarket.
"""

#distrubution of plot of Total Profit vs month
from matplotlib.ticker import FuncFormatter
# Assuming 'data' is your DataFrame and 'month' and 'Profit' are your columns

# Calculate total profit per Month
profit_by_year = data.groupby('Order Month')['Profit'].sum().sort_values(ascending=False)

# Create the bar plot
plt.figure(figsize=(18, 8))
ax = sns.barplot(x=profit_by_year.index, y=profit_by_year.values, color="yellow")
plt.title('Total Profit by Month')
plt.xlabel('Month')
plt.ylabel('Total Profit')
ax.yaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{int(x):,}'))
ax.bar_label(ax.containers[0], labels=[f'{int(value):,}' for value in profit_by_year.values]) #fixed this
plt.xticks(rotation=90)
# Format y-axis labels with commas for thousands
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)
# Add bar labels with formatted values
#ax.bar_label(ax.containers[0]) #this line was redundant
plt.tight_layout()  # Adjust layout to prevent labels from overlapping
plt.show()

"""**Analyzing Sales by Category**"""

# Analyzing Sales by Category
# Summing sales for each category to identify high-selling product categories
category_columns = [col for col in data.columns if col.startswith('Category_')]
sales_by_category = data[category_columns].multiply(data['Sales'], axis=0).sum().reset_index()
sales_by_category.columns = ['Category', 'Total Sales']
data.head()

"""**Visualizing Sales by Category**"""

# Assuming 'data' is your DataFrame and 'Sales' is your column

# Calculate the total sales across all categories
total_sales = data['Sales'].sum()

# Display the total sales
print("Total Sales:", total_sales)

# Assuming 'data' is your DataFrame and 'Category' and 'Sales' are your columns

# Calculate total sales per category
sales_by_category = data.groupby('Category')['Sales'].sum()

# Display total sales for each category
for category, total_sales in sales_by_category.items():
    print(f"Total sales for {category}: {total_sales}")

# Visualizing Sales by Category
# Creating a bar plot to showcase the distribution of total sales by each product category
plt.figure(figsize=(10, 6))
# Convert sales_by_category to DataFrame
sales_by_category_df = sales_by_category.reset_index()
sns.barplot(x='Sales', y='Category', data=sales_by_category_df, palette='viridis') # Use 'Sales' for x-axis
plt.title('Distribution of Sales by Category')
plt.xlabel('Total Sales')
plt.ylabel('Category')
plt.show()

# Sales Trends Over Time
# Grouping data by 'Order Date' and plotting sales trends to observe seasonality or overall trends
# The original line caused the error by trying to sum datetime64 values.
# Instead, we select the 'Sales' column before applying sum() to only consider numerical data.
data_time = data.groupby('Order Date')['Sales'].sum().reset_index()
plt.figure(figsize=(12, 6))
sns.lineplot(data=data_time, x='Order Date', y='Sales', marker='o')
plt.title('Sales Trends Over Time')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.xticks(rotation=45)
plt.grid()
plt.show()

"""**Correlation Analysis**"""

# Select only numerical features for correlation analysis
numerical_data = data.select_dtypes(include=['number'])

# Calculate the correlation matrix
corr = numerical_data.corr()

# Plot the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(corr, annot=True, fmt='.2f', cmap='coolwarm', square=True, cbar=True)
plt.title('Correlation Heatmap')
plt.show()

"""# Feature Engineering:

Additional temporal features like Order Year, Order Month, and Order Day of Week were extracted from the Order Date to enhance the model's understanding of time-based patterns.

**Normalizing Numerical Features**
"""

# Import the necessary module
from sklearn.model_selection import train_test_split

# Linear Regression Model
# Defining features and target variable for predicting 'Profit'
X = data.drop(['Profit', 'Order Date'], axis=1)
y = data['Profit']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

# Assuming 'data' is your original DataFrame

# Defining features and target variable for predicting 'Profit'
X = data.drop(['Profit', 'Order Date'], axis=1)
y = data['Profit']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# One-hot encode categorical features
categorical_cols = X_train.select_dtypes(include=['object']).columns.tolist() # Get a list of categorical columns
X_train = pd.get_dummies(X_train, columns=categorical_cols, drop_first=True) # One-hot encode and drop first category to avoid dummy trap
X_test = pd.get_dummies(X_test, columns=categorical_cols, drop_first=True)  # Apply same encoding to test set
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

# Assuming 'data' is your original DataFrame

# Defining features and target variable for predicting 'Profit'
X = data.drop(['Profit', 'Order Date'], axis=1)
y = data['Profit']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# One-hot encode categorical features
categorical_cols = X_train.select_dtypes(include=['object']).columns.tolist() # Get a list of categorical columns
X_train = pd.get_dummies(X_train, columns=categorical_cols, drop_first=True) # One-hot encode and drop first category to avoid dummy trap
X_test = pd.get_dummies(X_test, columns=categorical_cols, drop_first=True)  # Apply same encoding to test set

# Adjust column names in X_test to match X_train if necessary
missing_cols = set(X_train.columns) - set(X_test.columns)

"""**Feature Engineering**"""

# Feature Engineering
# Extracting 'Order Year', 'Order Month', and 'Order Day of Week' from the 'Order Date' column
data['Order Year'] = data['Order Date'].dt.year
data['Order Month'] = data['Order Date'].dt.month
data['Order Day of Week'] = data['Order Date'].dt.dayofweek
data.head()

"""**Linear Regression Model**"""

!pip install scikit-learn
# Import necessary libraries
import pandas as pd
from sklearn.model_selection import train_test_split # Importing train_test_split function

# Linear Regression Model
# Defining features and target variable for predicting 'Profit'
X = data.drop(['Profit', 'Order Date'], axis=1)
y = data['Profit']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""**Linear Regression Model**"""

# Normalizing features
# Import necessary libraries
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer

# Assuming 'data' is your DataFrame

# Defining features and target variable for predicting 'Profit'
X = data.drop(['Profit', 'Order Date'], axis=1)
y = data['Profit']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a list of numerical and categorical features
numerical_features = X.select_dtypes(include=['number']).columns.tolist()
categorical_features = X.select_dtypes(include=['object']).columns.tolist()

# Create a ColumnTransformer to apply different preprocessing to different columns
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numerical_features),
        ('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), categorical_features)]) # handle_unknown='ignore' for unseen values in test set

# Apply the preprocessing to the training and test data
X_train_normalized = preprocessor.fit_transform(X_train)
X_test_normalized = preprocessor.transform(X_test)

# Import LinearRegression
from sklearn.linear_model import LinearRegression
# Training the Linear Regression Model
model = LinearRegression()
model.fit(X_train_normalized, y_train)

"""**Model Evaluation**"""

# Import mean_squared_error and r2_score
from sklearn.metrics import mean_squared_error, r2_score
# Model Evaluation
y_pred = model.predict(X_test_normalized)
mse = mean_squared_error(y_test, y_pred) # Now mean_squared_error is defined
r2 = r2_score(y_test, y_pred) # Now r2_score is defined
print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

"""**Random Forest Classifier**"""

# Random Forest Classifier for Category Prediction
# Using RandomForestClassifier to classify whether a sale belongs to the 'Category_Beverages'
import pandas as pd # Import the pandas library

# Check if 'Category_Beverages' column exists
if 'Category_Beverages' not in data.columns:
    # If not, create it and initialize with 0s (or any suitable default value)
    data['Category_Beverages'] = 0

# Now you can safely convert the column to integers
data['Category_Beverages'] = data['Category_Beverages'].astype(int)
data['Category_Beverages'] = data['Category_Beverages'].astype(int)
y = data['Category_Beverages']
X = data.drop(category_columns + ['Sales', 'Order Date'], axis=1)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

"""# Visualization of Actual vs. Predicted Profit:

 A scatter plot was created to visually assess the accuracy of the Linear Regression model, with an overlayed line of equality. This visualization highlights areas where the model under-predicted or over-predicted, providing a clear representation of the model’s performance.

**Visualizing Actual vs. Predicted Profit**
"""

# Visualizing Actual vs. Predicted Profit
import matplotlib.pyplot as plt

# Set the figure size
plt.figure(figsize=(12, 8))

# Scatter plot for actual vs. predicted profits
plt.scatter(y_test, y_pred, alpha=0.7, color='blue', edgecolor='k', s=50, label='Predicted Profit')

# Line of equality (y = x) for visual reference
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2, label='Perfect Prediction (y = x)')

# Add plot labels and title
plt.xlabel('Actual Profit', fontsize=14)
plt.ylabel('Predicted Profit', fontsize=14)
plt.title('Actual vs. Predicted Profit', fontsize=16)

# Add annotations to improve plot readability
plt.annotate('Under-predictions', xy=(y_test.max()*0.8, y_test.max()*0.2), color='green', fontsize=12)
plt.annotate('Over-predictions', xy=(y_test.max()*0.2, y_test.max()*0.8), color='orange', fontsize=12)

# Add grid lines for easier visual comparison
plt.grid(True, linestyle='--', alpha=0.6)

# Add a legend for clarity
plt.legend(fontsize=12)

# Show the plot
plt.show()

"""**INSIGHTS:**

This scatter plot shows the relationship between actual and predicted profits, with a diagonal red dashed line representing the line of perfect prediction (
𝑦
=
𝑥
y=x). Here are some insights based on the plot:

Over- and Under-predictions: The points above the red line indicate over-predictions, where the predicted profit is higher than the actual profit, while the points below the line indicate under-predictions, where the predicted profit is lower.

Clustered Predictions: The data points are densely clustered around the extreme values of the actual profit (close to 0 and 1), suggesting that the model might be predicting consistently around certain values without fully capturing the range of actual profits.

Deviation from Perfect Prediction: Since most points do not lie close to the perfect prediction line, it indicates that the model may have limited accuracy or generalization in capturing the true profit values.

In summary, the model tends to overestimate or underestimate profits significantly, as most predicted values are not aligned with the actual profit values across the entire range. The clustering at extreme values suggests the model might not be capturing the middle ranges of profit accurately.

# Sales Distribution by Year:

A pie chart depicted the proportion of sales by year, offering a snapshot of the growth or decline in sales across different years, which can be essential for understanding business trends over time.

**Sales Distribution by Year**
"""

# Sales Distribution by Year
data['Year'] = data['Order Date'].dt.year # Use dt accessor to get the year
yearly_sales = data.groupby('Year')['Sales'].sum().reset_index()
plt.figure(figsize=(10, 8))
plt.pie(yearly_sales['Sales'], labels=yearly_sales['Year'], autopct='%1.1f%%', startangle=140)
plt.title('Sales Distribution by Year')
plt.axis('equal')
plt.show()

"""**INSIGHTS:**

In 2018, the sales distribution reached its highest point at approximately 33.4%, while 2015 recorded the lowest sales distribution compared to the subsequent years, 2016 and 2017.

# Conclusion :
This analysis of the Supermart Grocery Sales - Retail Analytics Dataset involved multiple stages, including data cleaning, visualization, feature engineering, and machine learning modeling to uncover insights into sales trends, understand relationships between features, and predict profits
"""
